#include <HLSLSupport.cginc>
#include "ComplexOperators.compute"
#pragma kernel TimeSpectrum
#pragma kernel InversionAndPermutation
#pragma kernel FFTCompute
#pragma kernel DebugAmplitude

#pragma multi_compile_local SAMPLE_64 SAMPLE_128 SAMPLE_256 SAMPLE_512 SAMPLE_1024
#if defined(SAMPLE_1024)
#define SAMPLESIZE 1024
#define LOGSAMPLESIZE 10
#elif defined(SAMPLE_512)
#define SAMPLESIZE 512
#define LOGSAMPLESIZE 9
#elif defined(SAMPLE_256)
#define SAMPLESIZE 256
#define LOGSAMPLESIZE 8
#elif defined(SAMPLE_128)
#define SAMPLESIZE 128
#define LOGSAMPLESIZE 7
#else
#define SAMPLESIZE 64
#define LOGSAMPLESIZE 6
#endif

Texture2D<float4> h0;
Texture2D<float4> _butterflyTexture;//There might be a way to just compute this data in the ftt pass

#define M_PI 3.1415926535897932
//got rid of the direction variable and simply calling the vertical and horizontal pass separately
int direction;


CBUFFER_START(RarelyUpdated)
int N;
int L;
CBUFFER_END
RWTexture2DArray<float4> InOutFFTTextureArray;
groupshared float4 FFT_Buffer[2][SAMPLESIZE];

void ButterflyValues(uint step, uint index, out uint2 indices, out float2 twiddle)//this is essentially the reverse of the texture method, and is strictly better, as it doesn't use a texture, small as it was
{
    const float twoPi = 6.28318530718;
    const uint wingspan = SAMPLESIZE >> (step + 1);//this is equivalent to the "wingspan" of the butterfly in the old implementation, it converges towards 2 instead of SAMPLESIZE
    const uint w = wingspan * (index / wingspan);
    uint i = (w + index) % SAMPLESIZE;
    sincos(-twoPi / SAMPLESIZE * w, twiddle.y, twiddle.x);
    //here some implementation conditionally flip the sign the second twiddle factor, I found that it did not affect the results of this implementation 
    indices = uint2(i, i + wingspan);
}

float4 DoFft(uint pixelIndex, float4 input)
{
    FFT_Buffer[0][pixelIndex] = input;
    GroupMemoryBarrierWithGroupSync();
    bool pingPong = false;
    
    [unroll(LOGSAMPLESIZE)]
    for (uint step = 0; step < LOGSAMPLESIZE; step++)
    {
        uint2 inputsIndices;
        float2 twiddle;
        ButterflyValues(step, pixelIndex, inputsIndices, twiddle);
        
        float4 A = FFT_Buffer[pingPong][inputsIndices.y];
        
        FFT_Buffer[!pingPong][pixelIndex] = FFT_Buffer[pingPong][inputsIndices.x] + float4(cmp_multiply(twiddle,A.xy),cmp_multiply(twiddle,A.zw));
        pingPong = !pingPong;
        GroupMemoryBarrierWithGroupSync();
    }
    
    return FFT_Buffer[pingPong][pixelIndex];
}
[numthreads(SAMPLESIZE,1,1)]
void FFTCompute(uint3 id : SV_DispatchThreadID)
{
    const uint3 targetIndex = (direction ? id.yxz : id.xyz);
    InOutFFTTextureArray[targetIndex] = DoFft(id.x,InOutFFTTextureArray[targetIndex]);
}
float4 DoInversionAndPermutation(float4 input, uint2 id)
{
    const int2 X = id.xy;
    const float perm = (int(X.x + X.y) & 1) ? -1.0f : 1.0f;//true if x+y is odd
    return perm*(input/float(SAMPLESIZE*SAMPLESIZE));
}
[numthreads(16,16,1)]
void InversionAndPermutation(uint3 id: SV_DispatchThreadID)
{
    InOutFFTTextureArray[id] = DoInversionAndPermutation(InOutFFTTextureArray[id],id.xy);
}
    float t;//this needs to be "tiled" somehow to not raise forever (and break)
    RWTexture2DArray<float4> timeSpectrumResults;
    [numthreads(16,16,1)]
    void TimeSpectrum(uint3 id: SV_dispatchThreadID)
    {
        float2 X = float2(id.xy) - (float(SAMPLESIZE)/2.0);
        float2 K = float2(2.0* M_PI * X.x/L, 2.0 * M_PI * X.y/L);

        float mag = length(K);
        if(mag < 0.00001) mag = 0.00001;

        const float w = sqrt(9.81 * mag);//dispertion relation that controls wave size per frequency
        
        //leaving this commented to show the intent
        // const float2 fourier_amplitude = h0_k[id.xy];
        // const float2 fourier_amplitude_conjugate = h0_MinusK[id.xy];
        float4 fourierAmplitudes = h0[id.xy];
        float cos_wt = cos(w*t);
        float sin_wt = sin(w *t);

        //euler formula
        const float2 exp_iwt = float2(cos_wt,sin_wt);
        const float2 exp_iwt_inv = float2(cos_wt,-sin_wt);
    
        //dy
        const float2 h_kt_dy = cmp_add(cmp_multiply(fourierAmplitudes.xy,exp_iwt)
            ,cmp_multiply(fourierAmplitudes.zw,exp_iwt_inv));
        //dx
        const float2 dx = float2(0.0,-K.x/mag);
        const float2 h_kt_dx = cmp_multiply(dx,h_kt_dy);
        
        //dz
        const float2 dz = float2(0.0,-K.y/mag);
        const float2 h_kt_dz = cmp_multiply(dz, h_kt_dy);
        //derivatives
        
        const float2 h_kt_dxx = -(K.x * K.x * (1/mag) * h_kt_dy );//not very rigorous but it might be correct in this case
        const float2 h_kt_dyx =  K.x * float2(-h_kt_dy.y,h_kt_dy.x);
        const float2 h_kt_dzx = -(K.x * K.y *(1/mag)* h_kt_dy);//same as h_kt_dxz

        const float2 h_kt_dyz = K.y * float2(-h_kt_dy.y,h_kt_dy.x);
        const float2 h_kt_dzz = -(K.y * K.y * (1/mag) * h_kt_dy );
        
        timeSpectrumResults[id] =             float4(h_kt_dx,h_kt_dy);
        timeSpectrumResults[uint3(id.xy,1)] = float4(h_kt_dz,h_kt_dxx);
        timeSpectrumResults[uint3(id.xy,2)] = float4(h_kt_dyx,h_kt_dzx);
        timeSpectrumResults[uint3(id.xy,3)] = float4(h_kt_dyz,h_kt_dzz);//in another implementation, it is possible to pack them by pair, but I don't understand how that might work
    }
    RWTexture2D<float4> DebugAmplitudeTexture;
    [numthreads(16,16,1)]
    void DebugAmplitude(uint3 id : SV_dispatchThreadID)
    {
        float4 value = timeSpectrumResults[id];
        const float4 pixel = float4(value.z,0,0,1);
        DebugAmplitudeTexture[id.xy] = pixel;
        uint2 offsetIndex = float2(id.x,id.y + SAMPLESIZE);
        DebugAmplitudeTexture[offsetIndex.xy] = pixel;
    }

