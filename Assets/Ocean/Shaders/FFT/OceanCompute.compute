#include <HLSLSupport.cginc>
#include "ComplexOperators.compute"
#define _NORMALMAP
#pragma kernel TimeSpectrum
#pragma kernel InversionAndPermutation
#pragma kernel FFTCompute
#pragma kernel DebugAmplitude
#ifdef _NORMALMAP
#pragma kernel ComputeNormal
#endif

#pragma multi_compile_local SAMPLE_64 SAMPLE_128 SAMPLE_256 SAMPLE_512 SAMPLE_1024

#if defined(SAMPLE_1024)
#define SAMPLESIZE 1024
#define LOGSAMPLESIZE 10
#elif defined(SAMPLE_512)
#define SAMPLESIZE 512
#define LOGSAMPLESIZE 9
#elif defined(SAMPLE_256)
#define SAMPLESIZE 256
#define LOGSAMPLESIZE 8
#elif defined(SAMPLE_128)
#define SAMPLESIZE 128
#define LOGSAMPLESIZE 7
#else
#define SAMPLESIZE 64
#define LOGSAMPLESIZE 6
#endif

Texture2D<float4> h0;
Texture2D<float4> _butterflyTexture;//There might be a way to just compute this data in the ftt pass

#define M_PI 3.1415926535897932
//got rid of the direction variable and simply calling the vertical and horizontal pass separately
int direction;


CBUFFER_START(RarelyUpdated)
int N;
int LogN;
int L;
#ifdef _NORMALMAP
float pixelStep;//distance in Unity units between each horizontal pixel (as real dimensions are lost to concession made to float precision)
float HorizontalScaling;
float VerticalScaling;
#endif
CBUFFER_END
RWStructuredBuffer<Complex3> InOutFFTBuffer;//Size*size buffer taking the time dependent spectrum as input and outputting displacements (said displacement still need to be permuted and inverted)
//TODO add a groupshared [2][N] sized buffer to cut down on buffer access, it requires significantly refactoring the butterfly texture
//TODO extract the fft computation to reuse it in different kernels (like normals)
void FFTOperation(int2 id)
{
    int2 X = direction == 0 ? id.xy : id.yx;
    const uint Index = (X.x + X.y*SAMPLESIZE);//direction == 0 ? (id.x + id.y*N) : (id.y + id.x*N);
    const uint HalfBufferSize = SAMPLESIZE*SAMPLESIZE;
    bool WriteBackHalfOfBuffer = true;
    DeviceMemoryBarrierWithGroupSync();
    [unroll(LOGSAMPLESIZE)]
    for(int Stage = 0; Stage < LOGSAMPLESIZE; Stage++)
    {
        const float4 ButterflyData = _butterflyTexture[int2(Stage,id.x)];
        const float2 w = ButterflyData.xy;//twiddle
        const uint ReadOffset = (WriteBackHalfOfBuffer ? 0 : HalfBufferSize);
        const uint WriteOffset = (WriteBackHalfOfBuffer ? HalfBufferSize : 0);
        Complex3 p;
        Complex3 q;
        if(direction == 0)//uniform branch, acceptable
            {
                p = InOutFFTBuffer[ButterflyData.z + SAMPLESIZE*X.y + ReadOffset];
                q = InOutFFTBuffer[ButterflyData.w + SAMPLESIZE*X.y + ReadOffset];
            }else
            {
                p = InOutFFTBuffer[X.x + SAMPLESIZE*ButterflyData.z + ReadOffset];
                q = InOutFFTBuffer[X.x + SAMPLESIZE*ButterflyData.w + ReadOffset];
            }
        
        const Complex3 H = cmp_add(p, cmp_multiply(w, q));
        InOutFFTBuffer[Index + WriteOffset] = H;
        
        WriteBackHalfOfBuffer = !WriteBackHalfOfBuffer;
        DeviceMemoryBarrierWithGroupSync();//this buffer is probably considered device memory
    }
}
[numthreads(SAMPLESIZE,1,1)]
void FFTCompute(uint3 id : SV_DispatchThreadID)
{
    FFTOperation(id.xy);
}


RWTexture2D<float4> displacement;
#ifdef _NORMALMAP
RWTexture2D<float4> normalMap;
float3 getPositionFromDisplacement(uint2 index)
{
    float3 result = displacement[index].xyz;
    uint2 localIndex = index % 2;
    result.xz *= HorizontalScaling;
    result.x += localIndex.x *pixelStep;
    result.z += localIndex.y *pixelStep;
    result.y *= VerticalScaling;
    return result;
}
[numthreads(8,8,1)]
void ComputeNormal(uint3 id : SV_DispatchThreadID)//working on 2x2 pixel quads, choose the number of threads accordingly
{
    const uint2 index00 = id.xy*2;
    const uint2 index01 = uint2(index00.x,index00.y+1);
    const uint2 index10 = uint2(index00.x+1,index00.y);
    const uint2 index11 = uint2(index10.x,index01.y);

    float3 position00 = getPositionFromDisplacement(index00);
    float3 position01 = getPositionFromDisplacement(index01);
    float3 position10 = getPositionFromDisplacement(index10);
    float3 position11 = getPositionFromDisplacement(index11);
    
    const float3 ddx0 = (position00.xyz - position10.xyz)/(position00.x - position10.x);
    const float3 ddx1 = (position01.xyz - position11.xyz)/(position01.x - position11.x);
    const float3 ddy0 = (position00.xyz - position01.xyz)/(position00.z - position01.z);
    const float3 ddy1 = (position10.xyz - position11.xyz)/(position10.z - position11.z);

    float3 normal00 = float3(normalize(cross(ddx0,ddy0)));
    float3 normal01 = float3(normalize(cross(ddx0,ddy1)));
    float3 normal10 = float3(normalize(cross(ddx1,ddy0)));
    float3 normal11 = float3(normalize(cross(ddx1,ddy1)));

    const int sign00 = sign(normal00.y);
    const int sign01 = sign(normal01.y);
    const int sign10 = sign(normal10.y);
    const int sign11 = sign(normal11.y);

    normalMap[index00] = float4(sign00 * normal00,1.0);
    normalMap[index01] = float4(sign01 * normal01,1.0);
    normalMap[index10] = float4(sign10 * normal10,1.0);
    normalMap[index11] = float4(sign11 * normal11,1.0);
    
}
#endif

[numthreads(16,16,1)]
void InversionAndPermutation(uint3 id : SV_DispatchThreadID)
{
    const int2 X = id.xy;
    const uint BufferIndex = id.x + id.y*SAMPLESIZE;
    
    const float perm = (int(X.x + X.y) & 1) ? -1.0f : 1.0f;//true if x+y is odd
    
    
    Complex3 Data = InOutFFTBuffer[BufferIndex];//guaranteed to be the correct half of the buffer as there are two passes of equal length
    const float3 h = float3(Data.dx.x,Data.dy.x,Data.dz.x);//taking the real part of all components
    displacement[X] = float4(perm*(h/float(SAMPLESIZE*SAMPLESIZE)),1);
}
    float t;//this needs to be "tiled" somehow to not raise forever (and break)
    RWStructuredBuffer<Complex3> tilde_hkt;//a texture buffer might lay this out in memory like a texture
    
    [numthreads(16,16,1)]
    void TimeSpectrum(uint3 id: SV_dispatchThreadID)
    {
        float2 X = float2(id.xy) - (float(SAMPLESIZE)/2.0);
        float2 K = float2(2.0* M_PI * X.x/L, 2.0 * M_PI * X.y/L);

        float mag = length(K);
        if(mag < 0.00001) mag = 0.00001;

        const float w = sqrt(9.81 * mag);//dispertion relation that controls wave size per frequency
        
        //leaving this commented to show the intent
        // const float2 fourier_amplitude = h0_k[id.xy];
        // const float2 fourier_amplitude_conjugate = h0_MinusK[id.xy];
        float4 fourierAmplitudes = h0[id.xy];
        float cos_wt = cos(w*t);
        float sin_wt = sin(w *t);

        //euler formula
        const float2 exp_iwt = float2(cos_wt,sin_wt);
        const float2 exp_iwt_inv = float2(cos_wt,-sin_wt);
    
        //dy
        const float2 h_kt_dy = cmp_add(cmp_multiply(fourierAmplitudes.xy,exp_iwt)
            ,cmp_multiply(fourierAmplitudes.zw,exp_iwt_inv));
        //dx
        const float2 dx = float2(0.0,-K.x/mag);
        const float2 h_kt_dx = cmp_multiply(dx,h_kt_dy);
        
        //dz
        const float2 dz = float2(0.0,-K.y/mag);
        const float2 h_kt_dz = cmp_multiply(dz, h_kt_dy);
        //const float2 h_kt_dzx = -(h_kt_dy * K.x * K.y * (1/mag));//not very rigorous but it might be correct in this case
        const Complex3 AmplitudeResult = { h_kt_dx, h_kt_dy, h_kt_dz};
        tilde_hkt[id.x + id.y*SAMPLESIZE] = AmplitudeResult;
    
    }
    RWTexture2D<float4> DebugAmplitudeTexture;
    [numthreads(16,16,1)]
    void DebugAmplitude(uint3 id : SV_dispatchThreadID)
    {
        DebugAmplitudeTexture[id.xy] = float4(tilde_hkt[id.x + id.y*SAMPLESIZE].dy.y,0,0,1);
    }

